<!DOCTYPE html>
<html>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">


    <head> 
        <title>Billiard</title>
        <style>
			body {
				font-family: verdana; 
				font-size: 15px;
			}			
			.button {
				background-color: #606060;
				border: none;
				color: white;
				padding: 10px 32px;
				font-size: 16px;
				margin: 4px 2px;
				cursor: pointer;
			}
			.slider {
				-webkit-appearance: none;
				width: 80px;
				height: 6px;
				border-radius: 5px;
				background: #d3d3d3;
				outline: none;
				opacity: 0.7;
				-webkit-transition: .2s;
				transition: opacity .2s;
			}
		</style>
    </head>

    <body>
        <button class="button" onclick="setupScene()">Restart</button>
        Restitution: <input type="range" min="0", max="10", value="10" id="restitutionSlider" class="slider">
        <br>
        <canvas id="myCanvas" style="border:2px solid"></canvas>

        <script>

        // canvas setup

        var canvas = document.getElementById("myCanvas");
        var c = canvas.getContext("2d");

        canvas.width = window.innerWidth - 20;
        canvas.height = window.innerHeight - 100;

        var simMinWidth = 20.0;
        var cScale = Math.min(canvas.width, canvas.height) / simMinWidth;
        var simWidth = canvas.width / cScale;
        var simHeight = canvas.height / cScale;

        function cX(pos) {
            return pos.x * cScale;
        }

        function cY(pos) {
            return canvas.height - pos.y * cScale;
        }

        // Vector math
        class Vector2 {
            constructor(x=0.0, y=0.0){
                this.x = x;
                this.y = y;
            }

            set(v) {
                this.x = v.x;
                this.y = v.y;
            }

            clone() {
                return new Vector2(this.x, this.y);
            }


            add(v, s=1.0) {
                this.x += v.x * s;
                this.y += v.y * s;
                return this;
            }

            addVectors(a, b) {
                this.x = a.x + b.x;
                this.y = a.y + b.y;
                return this;
            }

            subtractVectors(a, b) {
                this.x = a.x - b.x;
                this.y = a.y - b.y;
                return this;
            }

            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }

            scale(s) {
                this.x *= s;
                this.y *= s;
            }

            dot(v) {
                return this.x * v.x + this.y * v.y;
            }

        }

        // physics scence
        class Ball {
            constructor(radius, mass, pos, vel) {
                this.radius = radius;
                this.mass = mass;
                this.pos = pos;
                this.vel = vel;
            }

            simulate(dt, gravity){
                this.vel.add(gravity, dt);
                this.pos.add(this.vel, dt);
            }
        }

        var physicsScene = 
        {
            gravity: new Vector2(0.0, 0.0),
            dt: 1.0 / 60.0,
            worldSize: new Vector2(simWidth, simHeight),
            paused: true,
            balls: [],
            restitution: 1.0
        }

        function setupScene()
        {
            physicsScene.balls = [];
            var numBalls = 20;

            for (i = 0; i < numBalls; i++) {

                var radius = 0.05 + Math.random() * 0.1;
                var mass = Math.PI * radius *radius;
                var pos = new Vector2(Math.random() * simWidth, Math.random() * simHeight);
                var vel = new Vector2(-1.0 + 2.0 * Math.random(), -1.0 + 2.0 * Math.random());

                physicsScene.balls.push(new Ball(radius, mass, pos, vel));
            }
        }

        
        // drawing 
        function draw() {
            c.clearRect(0, 0, canvas.width, canvas.height);

            c.fillStyle = "#FF0000";

            for (i = 0; i < physicsScene.balls.length; i++) {
                var ball = physicsScene.balls[i];
                c.beginPath();
                c.arc(cX(ball.pos), cY(ball.pos), ball.radius * cScale, 0, 2 * Math.PI);
                c.closePath();
                c.fill();
            }
        }

        // collision handling ----
        function handleCollision(ball1, ball2, restitution)
        {
            var dir = new Vector2();
            dir.subtractVectors(ball2.pos, ball1.pos);
            var d = dir.length();
            if (d == 0.0 || d > ball1.radius + ball2.radius) {
                return;
            }

            dir.scale(1.0 / d);

             
        }

        // simulate

        function simulate() {
            ball.vel.x += gravity.x * timeStep;
            ball.vel.y += gravity.y * timeStep;

            ball.pos.x += ball.vel.x * timeStep;
            ball.pos.y += ball.vel.y * timeStep;

            if (ball.pos.y - ball.radius < 0.0) {
                ball.pos.y = ball.radius;
                ball.vel.y = -ball.vel.y;
            }

            if (ball.pos.x + ball.radius > simWidth) {
                ball.pos.x = simWidth - ball.radius;
                ball.vel.x = -ball.vel.x;
            }

            if (ball.pos.x - ball.radius < 0.0) {
                ball.pos.x = ball.radius;
                ball.vel.x = -ball.vel.x;
            }
            
        }

        // make browser to call us repeatedly
        function update() {
            simulate();
            draw();
            requestAnimationFrame(update);
        }

        update();

        </script>
    </body>
</html>