<!DOCTYPE html>
<html>
    <head>
        <title>Cannonball VR</title>
        <style>
            body {
                font-family: Verdana, Geneva, Tahoma, sans-serif;
                font-size: 15px;
            }
        </style>
    </head>

    <body>
        <h1>Cannonball VR</h1>
        <button id="buttonRun" onclick="run()">Run</button>
        <button onclick="restart()">Restart</button>

        <br><br>
        <div id = "container"></div>

        <script src="https://unpkg.com/three@0.139.2/build/three.min.js"></script>
        <script src="https://unpkg.com/three@0.139.2/examples/js/controls/OrbitControls.js"></script>
        <script>

            // scene steup
            var threeScene;
            var renderer;
            var camera;
            var cameraControls;


            // physics scene
            var physicsSence = {
                gravity: new THREE.Vector3(0, -10, 0),
                dt: 1.0 / 60.0,
                worldSize: { x: 1.5, z: 2.5 },
                paused: true,
                objects: []
            }

            class Ball {
                constructor(pos, radius, vel)
                {
                    // physics data
                    this.pos = pos;
                    this.radius = radius;
                    this.vel = vel;

                    // visual mesh
                    var geometry = new THREE.SphereGeometry(radius, 32, 32);
                    var material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                    this.visMesh = new THREE.Mesh(geometry, material);
                    this.visMesh.position.copy(this.pos);
                    threeScene.add(this.visMesh);
                }

                simulte(){
                    this.vel.addScaledVector(physicsSence.gravity, physicsSence.dt);
                    this.pos.addScaledVector(this.vel, physicsSence.dt);

                    if (this.pos.x < -physicsSence.worldSize.x)
                    {
                          this.pos.x = -physicsSence.worldSize.x;
                          this.vel.x *= -1;
                    }
                    if (this.pos.x > physicsSence.worldSize.x)
                    {
                            this.pos.x = physicsSence.worldSize.x;
                            this.vel.x *= -1;
                    }
                    if (this.pos.z < -physicsSence.worldSize.z)
                    {
                          this.pos.z = -physicsSence.worldSize.z;
                          this.vel.z *= -1;
                    }
                    if (this.pos.z > physicsSence.worldSize.z)
                    {
                            this.pos.z = physicsSence.worldSize.z;
                            this.vel.z *= -1;
                    }
                    if (this.pos.y - this.radius < 0.0)
                    {
                        this.pos.y = this.radius;
                        this.vel.y = -this.vel.y;
                    }

                    this.visMesh.position.copy(this.pos);
                }
            }

            function initPhysics() {
                var radius = 0.2;
                var pos = new THREE.Vector3(radius, radius, radius);
                var vel = new THREE.Vector3(2.0, 5.0, 3.0);

                physicsSence.objects.push( new Ball(pos, radius, vel) );
            }


            function simulate() {
                if (physicsSence.paused)
                    return;

                for (var i = 0; i < physicsSence.objects.length; i++)
                {
                    physicsSence.objects[i].simulte();
                }

            }

            function initThreeScene() {
                threeScene = new THREE.Scene();

                // Lights
                threeScene.add(new THREE.AmbientLight(0x505050));
                threeScene.fog = new THREE.Fog(0x000000, 0, 15);

                var spotLight = new THREE.SpotLight(0xffffff);
                spotLight.angle = Math.PI / 5;
                spotLight.penumbra = 0.2;
				spotLight.position.set( 2, 3, 3 );
				spotLight.castShadow = true;
				spotLight.shadow.camera.near = 3;
				spotLight.shadow.camera.far = 10;
				spotLight.shadow.mapSize.width = 1024;
				spotLight.shadow.mapSize.height = 1024;
				threeScene.add( spotLight );

                var dirLight = new THREE.DirectionalLight( 0x55505a, 1 );
				dirLight.position.set( 0, 3, 0 );
				dirLight.castShadow = true;
				dirLight.shadow.camera.near = 1;
				dirLight.shadow.camera.far = 10;

				dirLight.shadow.camera.right = 1;
				dirLight.shadow.camera.left = - 1;
				dirLight.shadow.camera.top	= 1;
				dirLight.shadow.camera.bottom = - 1;

				dirLight.shadow.mapSize.width = 1024;
				dirLight.shadow.mapSize.height = 1024;
				threeScene.add( dirLight );

                // Geometry
                var ground = new THREE.Mesh(
                    new THREE.PlaneBufferGeometry(20, 20, 1, 1),
                    new THREE.MeshPhongMaterial({ color: 0xa0adaf, shininess: 150 })
                )

                ground.rotation.x = - Math.PI / 2;
                ground.receiveShadow = true;
                threeScene.add(ground);

                var helper = new THREE.GridHelper(20, 20);
                helper.material.opacity = 1.0;
				helper.material.transparent = true;
				helper.position.set(0, 0.002, 0);
				threeScene.add( helper );

                // Renderer

				renderer = new THREE.WebGLRenderer();
				renderer.shadowMap.enabled = true;
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( 0.8 * window.innerWidth, 0.8 * window.innerHeight );
				window.addEventListener( 'resize', onWindowResize, false );
				container.appendChild( renderer.domElement );

                // Camera
						
				camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 100);
			    camera.position.set(0, 1, 4);
				camera.updateMatrixWorld();	

				threeScene.add( camera );

                // Camera Controls
                cameraControls = new THREE.OrbitControls( camera, renderer.domElement );
                cameraControls.zoomSpeed = 2.0;
                cameraControls.panSpeed = 0.4;

                // VR
                document.body.appendChild( THREE.VRButton.createButton( renderer ) );
                renderer.xr.enabled = true;
                renderer.setAnimationLoop(update);

            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }

            var paused = true;

            function run() {
                var button = document.getElementById("buttonRun");
                if(paused) 
                    button.innerHTML = "Stop";
                else
                    button.innerHTML = "Run";
                physicsSence.paused = !physicsSence.paused;
            }
            
            function restart() {
                location.reload();
            }

            function update() {
                simulate();
                renderer.render(threeScene, camera);
                
            }

            // ------------------------------------------
			// start copied code from THREE.js
					
			class VRButton {

				static createButton( renderer, options ) {

					if ( options ) {

						console.error( 'THREE.VRButton: The "options" parameter has been removed. Please set the reference space type via renderer.xr.setReferenceSpaceType() instead.' );

					}

					const button = document.createElement( 'button' );

					function showEnterVR( /*device*/ ) {

						let currentSession = null;

						async function onSessionStarted( session ) {

							session.addEventListener( 'end', onSessionEnded );

							await renderer.xr.setSession( session );
							button.textContent = 'EXIT VR';

							currentSession = session;

						}

						function onSessionEnded( /*event*/ ) {

							currentSession.removeEventListener( 'end', onSessionEnded );

							button.textContent = 'ENTER VR';

							currentSession = null;

						}

						//

						button.style.display = '';

						button.style.cursor = 'pointer';
						button.style.left = 'calc(50% - 50px)';
						button.style.width = '100px';

						button.textContent = 'ENTER VR';

						button.onmouseenter = function () {

							button.style.opacity = '1.0';

						};

						button.onmouseleave = function () {

							button.style.opacity = '0.5';

						};

						button.onclick = function () {

							if ( currentSession === null ) {

								// WebXR's requestReferenceSpace only works if the corresponding feature
								// was requested at session creation time. For simplicity, just ask for
								// the interesting ones as optional features, but be aware that the
								// requestReferenceSpace call will fail if it turns out to be unavailable.
								// ('local' is always available for immersive sessions and doesn't need to
								// be requested separately.)

								const sessionInit = { optionalFeatures: [ 'local-floor', 'bounded-floor', 'hand-tracking' ] };
								navigator.xr.requestSession( 'immersive-vr', sessionInit ).then( onSessionStarted );

							} else {

								currentSession.end();

							}

						};

					}

					function disableButton() {

						button.style.display = '';

						button.style.cursor = 'auto';
						button.style.left = 'calc(50% - 75px)';
						button.style.width = '150px';

						button.onmouseenter = null;
						button.onmouseleave = null;

						button.onclick = null;

					}

					function showWebXRNotFound() {

						disableButton();

						button.textContent = 'VR NOT SUPPORTED';

					}

					function stylizeElement( element ) {

						element.style.position = 'absolute';
						element.style.bottom = '20px';
						element.style.padding = '12px 6px';
						element.style.border = '1px solid #fff';
						element.style.borderRadius = '4px';
						element.style.background = 'rgba(0,0,0,0.1)';
						element.style.color = '#fff';
						element.style.font = 'normal 13px sans-serif';
						element.style.textAlign = 'center';
						element.style.opacity = '0.5';
						element.style.outline = 'none';
						element.style.zIndex = '999';

					}

					if ( 'xr' in navigator ) {

						button.id = 'VRButton';
						button.style.display = 'none';

						stylizeElement( button );

						navigator.xr.isSessionSupported( 'immersive-vr' ).then( function ( supported ) {

							supported ? showEnterVR() : showWebXRNotFound();

						} );

						return button;

					} else {

						const message = document.createElement( 'a' );

						if ( window.isSecureContext === false ) {

							message.href = document.location.href.replace( /^http:/, 'https:' );
							message.innerHTML = 'WEBXR NEEDS HTTPS'; // TODO Improve message

						} else {

							message.href = 'https://immersiveweb.dev/';
							message.innerHTML = 'WEBXR NOT AVAILABLE';

						}

						message.style.left = 'calc(50% - 90px)';
						message.style.width = '180px';
						message.style.textDecoration = 'none';

						stylizeElement( message );

						return message;

					}
				}
			};



            initThreeScene();
            initPhysics();
            update();

        </script>
    </body>
</html>